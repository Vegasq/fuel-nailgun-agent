#!/usr/bin/env ruby

begin
  require 'rubygems'
rescue LoadError
end
require 'ohai/system'
require 'json'
require 'httpclient'
require 'logger'
require 'optparse'
require 'yaml'

AGENT_CONFIG = "/etc/nailgun-agent/config.yaml"

class McollectiveConfig
  def initialize(logger)
    @logger = logger
    @configfile = '/etc/mcollective/server.cfg'
  end

  def get_config_by_key(find_key)
    found_key = nil
    found_value = nil
    # This code is from mcollective's sources
    File.open(@configfile, "r").each do |line|
      # strip blank spaces, tabs etc off the end of all lines
      line.gsub!(/\s*$/, "")
      unless line =~ /^#|^$/
        if (line =~ /(.+?)\s*=\s*(.+)/)
          key = $1
          val = $2
          if key == find_key
            found_key = key
            found_value = val
          end
        end
      end
    end

    if found_key
      return found_value
    else
      return nil
    end
  end

  def replace_identity(new_id)
    # check if id complies reqs
    raise 'Identities can only match /\w\.\-/' unless new_id.to_s.match(/^[\w\.\-]+$/)

    value_from_config = get_config_by_key('identity')

    if value_from_config == new_id.to_s
      @logger.info "MCollective is up to date with identity = #{new_id}"
    else
      config = File.open(@configfile, "rb").read
      unless value_from_config  # if key was not found
        config += "\nidentity = #{new_id}\n"
        @logger.info "Identity in mcollective server.cfg has not been found. Setting to '#{new_id}'"
        File.open(@configfile, "w") { |f| f.write(config) }
      else
        # Key found, but it has other value
        @logger.info "Replacing identity in mcollective server.cfg to new value = '#{new_id}'"
        config.gsub!(/^identity[ =].*$/, "identity = #{new_id}")
        File.open(@configfile, "w") { |f| f.write(config) }
      end
      puts `/sbin/service mcollective restart`
    end
  end
end


class NodeAgent
  def initialize(logger, url=nil)
    @logger = logger

    @api_default_address = "localhost"
    @api_default_port = "8000"

    @api_url = url

    if @api_url
      @api_url.chomp!('/')
    else
      begin
        cmdline = ::File.read("/proc/cmdline")
        api_ip = cmdline.match(/\burl=http:\/\/((\d{1,3}\.){3}\d{1,3})/)[1]
        @logger.info("Found admin node IP address in kernel cmdline: #{api_ip}")
      rescue
        @logger.info("Can't get API url from /proc/cmdline. Will use localhost.")
        api_ip = "127.0.0.1"
      end
      @api_url = "http://#{api_ip}:#{@api_default_port}/api"
    end

    @os = Ohai::System.new()
    @os.all_plugins
  end

  def put
    headers = {"Content-Type" => "application/json"}
    htclient = HTTPClient.new
    @logger.debug("Trying to put host info into #{@api_url}")
    res = htclient.put("#{@api_url}/nodes/", [_data].to_json, headers)
    if res.status < 200 or res.status >= 300
      @logger.error("HTTP PUT failed: #{res.inspect}")
    end
    return res
  end

  def post
    headers = {"Content-Type" => "application/json"}
    htclient = HTTPClient.new
    @logger.debug("Trying to create host using #{@api_url}")
    res = htclient.post("#{@api_url}/nodes/", _data.to_json, headers)
    return res
  end

  def _interfaces
    interfaces = @os[:network][:interfaces].inject([]) do |result, elm|
      result << { :name => elm[0], :addresses => elm[1]["addresses"] }
    end
    interfaces << { "default_interface" => @os["network"]["default_interface"] }
    interfaces << { "default_gateway" => @os["network"]["default_gateway"] }
    interfaces
  end

  def _mac
    @os[:macaddress]
  end

  def _metadata
    {
      :block_device => @os["block_device"].to_hash,
      :interfaces => _interfaces,
      :cpu => @os["cpu"].to_hash,
      :memory => @os["memory"].to_hash,
      :serial => _serial
    }
  end

  def _is_virtual
    begin
      if @os["virtualization"]["role"] == "guest"
        return true
      end
    rescue
    end
    return false
  end

  def _manufacturer
    if _is_virtual
      return @os["virtualization"]["system"].upcase
    else
      begin
        return @os[:dmi][:system][:manufacturer]
      rescue
        return "Unknown"
      end
    end
  end

  def _product_name
    if _is_virtual
      return @os["virtualization"]["role"]
    else
      begin
        return @os[:dmi][:system][:product_name]
      rescue
        return "Unknown"
      end
    end
  end

  def _serial
    begin
      return @os[:dmi][:system][:serial_number]
    rescue
      return "Unknown"
    end
  end

  def _data
    res = {
      :fqdn => @os[:fqdn],
      :mac => @os[:macaddress],
      :ip  => @os[:ipaddress],
      :manufacturer => _manufacturer,
      :platform_name => _product_name,
      :os_platform => @os[:platform],
      :meta => _metadata
    }

    res[:status] = @node_state if @node_state
    res
  end

  def update_state
    @node_state = nil
    if File.exist?("/etc/nailgun_systemtype")
      fl = File.open("/etc/nailgun_systemtype", "r")
      system_type = fl.readline.rstrip
      @node_state = "discover" if system_type == "bootstrap"
    else
      fl = File.open("/etc/nailgun_systemtype", "w")
      fl.puts("target")
    end
  end

end

def write_data_to_file(logger, filename, data)
  if File.exist?(filename)
    File.open(filename, 'r') do |fo|
      text = fo.read
    end
  else
    text = ''
  end

  if text != data
    begin
      File.open(filename, 'w') do |fo|
        fo.write(data)
      end
      logger.info("Writed data to file '#{filename}'. Data: #{data}")
    rescue Exception => e
      logger.warning("Can't write data to file '#{filename}'. Reason: #{e.message}")
    end
  else
    logger.info("File '#{filename}' is up to date.")
  end
end


logger = Logger.new(STDOUT)
logger.level = Logger::DEBUG

begin
  logger.info("Trying to load agent config #{AGENT_CONFIG}")
  url = YAML.load_file(AGENT_CONFIG)['url']
  logger.info("Obtained service url from config file: '#{url}'")
rescue Exception => e
  logger.info("Could not get url from configuration file: #{e.message}, trying other ways..")
end


agent = NodeAgent.new(logger, url)
agent.update_state

post_res = agent.post
if post_res.status == 409:
  put_res = agent.put
  new_id = JSON.parse(put_res.body)[0]['id']
else
  new_id = JSON.parse(post_res.body)['id']
end

mc_config = McollectiveConfig.new(logger)
mc_config.replace_identity(new_id)
write_data_to_file(logger, '/etc/nailgun_uid', new_id.to_s)
