#!/usr/bin/env ruby

# Copyright 2012, Mirantis

require 'rubygems'
require 'tmpdir'
require 'fileutils'
require 'json'
require 'httpclient'
require 'chef'

HTTP_DIR = "/var/www"
ADMIN_URL = "http://127.0.0.1:8000/api"

def create_cookbook(metafile)
  puts "Processing '#{metafile}' metadata file..."
  md = Chef::Cookbook::Metadata.new
  md.from_file(metafile)

  attr_id = create_attributes(metafile, md)
  create_recipes(metafile, md, attr_id)
end

def create_attributes(metafile, md)
  cook_name = md.name.empty? ? File.basename(File.dirname(metafile)) : md.name

  attrs_dir = File.join(File.dirname(metafile), "attributes")
  attr_file = File.join(attrs_dir, "exposed.rb")
  unless File.exists?(attr_file) and File.readable?(attr_file)
    puts "File '#{attr_file}' not found."
    return nil
  end
  node = Chef::Node.new

  attrs_url = "#{ADMIN_URL}/attributes"
  puts "Processing '#{attr_file}' attributes file..."
  node.from_file(attr_file)
  attr_hash = {'attribute' => node.attribute.to_hash,
               'cookbook' => cook_name,
               'version' => md.version,
              }
  attr_id = http_put(attrs_url, attr_hash.to_json)
  return attr_id
end

def create_recipes(metafile, md, attr_id)
  cook_name = md.name.empty? ? File.basename(File.dirname(metafile)) : md.name

  recipes_dir = File.join(File.dirname(metafile), "recipes")
  unless File.exists?(recipes_dir) and File.readable?(recipes_dir)
    puts "Recipes folder not found."
    return true
  end
  Dir.chdir(recipes_dir)
  recipes = Dir.glob("*.rb")

  recipes_tree_url = "#{ADMIN_URL}/recipes"
  dep_reg = /^# depends: "(\S+)"$/

  recipe_tree = []
  recipes.each do |recipe|
    depends = []
    File.readlines(recipe).each { |line| depends << $1 if dep_reg =~ line }
    recipe_name = File.basename(recipe, '.rb')
    recipe_full = "#{cook_name}::#{recipe_name}@#{md.version}"
    recipe_tree << {"recipe" => recipe_full, "depends" => depends, "attribute" => attr_id}
  end

  res = http_put(recipes_tree_url, recipe_tree.to_json)
  if res
    puts "Recipes for cookbook '#{cook_name}' created successfully"
  else
    puts "Skipping cookbook '#{cook_name}' from tar creation because of errors."
    return false
  end

  begin
    Dir.mktmpdir do |dir|
      cook_dir = File.join(dir, cook_name)
      tar_name = "#{cook_name}_#{md.version}.tar.gz"
      FileUtils.cp_r(File.dirname(metafile), cook_dir)
      system "cd \"#{dir}\" && tar czf \"#{tar_name}\" \"#{cook_name}\""
      FileUtils.mv(File.join(dir, "#{tar_name}"), HTTP_DIR)
      puts "Cookbook archived at '#{HTTP_DIR}/#{tar_name}'"
    end
  rescue Exception => e
    puts "Unknown error: #{e.message}"
    puts e.backtrace
    return false
  end
  return true
end

def http_put(url, data_json)
  headers = {"Content-Type" => "application/json"}
  cli = HTTPClient.new
  begin
    res = cli.put(url, data_json, headers)
  rescue Exception => e
    puts "Unknown error: #{e.message}"
    return nil
  end
  if res.status < 200 or res.status >= 300
    puts "Error received from server: #{res.inspect}"
    return nil
  end
  return res.content
end

### MAIN ###
puts "Provide path to cookbook for uploading" if ARGV.length == 0
ARGV.each do |src|
  case
  when /tar\.gz$/ =~ src
    # Could be cookbook
    Dir.mktmpdir do |tmpdir|
      src = File.expand_path(src)
      system "tar xzf \"#{src}\" -C \"#{tmpdir}\""

      folder = File.basename(src, '.tar.gz')
      metafile = File.join(tmpdir, folder, "metadata.rb")
      if File.exists?(metafile)
        create_cookbook(metafile)
      else
        puts "Error: File #{metafile} not found."
        puts "We suspect that '#{src}' contains '#{folder}' folder. Skipping."
      end
    end

  when File.exists?(File.join(src, "metadata.rb"))
    create_cookbook(File.expand_path(File.join(src, "metadata.rb")))

  when File.basename(src) == "metadata.rb"
    create_cookbook(File.expand_path(src))

  else
    puts "'#{src}' is not valid cookbook folder or not a valid cookbook archive. Skipping."
    puts "Valid cookbook archive should contain <folder>/metadata.rb file."
    next
  end
end
